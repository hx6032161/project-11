1.list 和 vector 的区别：
1.vector数据结构
vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
因此能高效的进行随机存取，时间复杂度为o(1);
但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

2.list数据结构
list是由双向链表实现的，因此内存空间是不连续的。
只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
但由于链表的特点，能高效地进行插入和删除。

使用区别：
     1 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector 
     2 如果你需要大量的插入和删除，而不关心随即存取，则应使用list 
     3 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque


II、map & multimap & unordered_map & unordered_multimap
2.1 map与multimap底层数据结构

map与multimap是STL中的关联容器、提供一对一key-value的数据处理能力； map与multimap的区别在于，multimap允许关键字重复，而map不允许重复。

这两个关联容器的底层数据结构均为红黑树，关于红黑树的理解可以参考教你透彻了解红黑树一文。

根据红黑树的原理，map与multimap可以实现O(lgn)的查找，插入和删除。

2.2 unordered_map 与unordered_multimap底层数据结构

unordered_map与unordered_multimap 对比2.1中的两种map在于其2.1中的两个容器实现了以key为序排列，也就是说map与multimap为有序的。

而unordered_map与unordered_multimap中key为无序排列，其底层实现为hash table，因此其查找时间复杂度理论上达到了O(n)，之所以说理论上是因为在理想无碰撞的情况下，而真实情况未必如此。

III、set & multiset & unordered_set & unordered_multiset
以上四种容器也都是关联容器，set系与map系的区别在于map中存储的是<key-value>，而set可以理解为关键字即值，即只保存关键字的容器。

3.1 set & multiset底层数据结构

set与multiset有序存储元素，这两种容器的底层实现与map一样都是红黑树，所以能实现O(lgn)的查找，插入，删除操作。

set与multiset的区别在于是否允许重复；

3.2 unordered_set & unordered_multiset

与unordered_map & unordered_multimap相同，其底层实现为hash table；


2.海量数据寻找top 堆排序

3.sql索引
https://www.cnblogs.com/selene/p/4474721.html

主键本身就是一个聚集索引
4.c++内存泄漏
内存泄露的检测

内存泄露的关键就是记录分配的内存和释放内存的操作，看看能不能匹配。跟踪每一块内存的声明周期，例如：每当申请一块内存后，把指向它的指针加入到List中，当释放时，再把对应的指针从List中删除，到程序最后检查List就可以知道有没有内存泄露了。Window平台下的Visual Studio调试器和C运行时（CRT）就是用这个原理来检测内存泄露。

5.所有情况下子类析构都会调用父类析构么
	所有对象析构时，最后都会调用其基类的析构函数。
	直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
6.什么情况下会发生多态
	有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。
7.c++中的static关键字
	1.static可以用作函数和变量的前缀，对于函数和全局变量来讲，static的作用仅限于隐藏.
	2.把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。
	3.static的第三个作用是默认初始化为0（static变量）
	4.类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。  

8.进程和线程的区别
	进程：是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
	线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。

9.sleep和阻塞进程会占用cpu么
	不会，会让出cpu 
10.多线程间通讯、多线程如何共享数据
	多线程通讯使用信号量：我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。多线程之间的通信能够避免对同一共享变量的争夺。
	1.如果线程执行的代码相同，多个线程共享同一个runnable对象时，将共享数据放在runnable对象

	2.如果多个线程执行的代码不同，将共享数据封装到一个对象中，将这个对象逐一传递给各个runnable对象

	3.如果多个线程执行的代码不同，将共享数据作为外部类的final成员变量，将不同的runnable对象作为内部类主动取数据

	4.将数据声明为static全局变量的方式（）